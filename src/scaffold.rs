//! Directory scaffolder for `comm-node init`.
//!
//! Creates the `.orchestrator/` directory structure in each domain,
//! writes `registry.json` for peer discovery, `PROTOCOL.md`
//! with communication rules, `status.json` for agent state,
//! and a domain-specific `CLAUDE.md` at each domain root.

use anyhow::Result;

use crate::config::ProjectConfig;
use crate::types::AgentStatus;

/// Scaffold the `.orchestrator/` directories for all configured domains.
///
/// Creates:
/// - `.orchestrator/artifacts/`
/// - `.orchestrator/inbox/`
/// - `.orchestrator/outbox/`
/// - `.orchestrator/registry.json`
/// - `.orchestrator/PROTOCOL.md`
/// - `.orchestrator/status.json`
/// - `CLAUDE.md` (domain root)
pub fn scaffold(config: &ProjectConfig) -> Result<()> {
    for (domain_id, domain_config) in &config.domains {
        let orch_dir = domain_config.path.join(".orchestrator");

        std::fs::create_dir_all(orch_dir.join("artifacts"))?;
        std::fs::create_dir_all(orch_dir.join("inbox"))?;
        std::fs::create_dir_all(orch_dir.join("outbox"))?;

        tracing::info!(domain = %domain_id, path = %orch_dir.display(), "scaffolded .orchestrator/");
    }

    write_registry(config)?;
    write_protocol(config)?;
    write_status(config)?;
    write_domain_claude_md(config)?;

    Ok(())
}

/// Write `registry.json` to each domain's `.orchestrator/` directory.
fn write_registry(config: &ProjectConfig) -> Result<()> {
    let registry: Vec<_> = config
        .domains
        .iter()
        .map(|(id, dc)| {
            serde_json::json!({
                "domain": id.as_str(),
                "description": dc.description,
            })
        })
        .collect();

    let registry_json = serde_json::to_string_pretty(&registry)?;

    for domain_config in config.domains.values() {
        let path = domain_config.path.join(".orchestrator/registry.json");
        std::fs::write(&path, &registry_json)?;
    }

    Ok(())
}

/// Write `PROTOCOL.md` to each domain's `.orchestrator/` directory.
fn write_protocol(config: &ProjectConfig) -> Result<()> {
    let protocol = include_str!("protocol_template.md");

    for domain_config in config.domains.values() {
        let path = domain_config.path.join(".orchestrator/PROTOCOL.md");
        std::fs::write(&path, protocol)?;
    }

    Ok(())
}

/// Write `status.json` to each domain's `.orchestrator/` directory.
///
/// Skips if the file already exists — the agent owns it once running.
fn write_status(config: &ProjectConfig) -> Result<()> {
    for (domain_id, domain_config) in &config.domains {
        let path = domain_config.path.join(".orchestrator/status.json");

        if path.exists() {
            tracing::info!(domain = %domain_id, "status.json already exists, skipping");
            continue;
        }

        let status = AgentStatus::new_idle(domain_id);
        let json = serde_json::to_string_pretty(&status)?;
        std::fs::write(&path, json)?;
        tracing::info!(domain = %domain_id, "wrote status.json");
    }

    Ok(())
}

/// Write a domain-specific `CLAUDE.md` to each domain's root directory.
///
/// Always overwrites — the comm-node owns this file.
fn write_domain_claude_md(config: &ProjectConfig) -> Result<()> {
    for (domain_id, domain_config) in &config.domains {
        let path = domain_config.path.join("CLAUDE.md");

        if path.exists() {
            tracing::warn!(domain = %domain_id, "overwriting existing CLAUDE.md");
        }

        // Build peer list (all domains except this one).
        let mut peers = String::new();
        for (other_id, other_dc) in &config.domains {
            if other_id != domain_id {
                peers.push_str(&format!("- **{}**: {}\n", other_id, other_dc.description));
            }
        }
        if peers.is_empty() {
            peers.push_str("- (no peers configured)\n");
        }

        // Build scope listing.
        let mut scopes = String::new();
        if domain_config.scope.is_empty() {
            scopes.push_str("- (no scope restrictions defined)\n");
        } else {
            for s in &domain_config.scope {
                scopes.push_str(&format!("- `{}`\n", s));
            }
        }

        let content = format!(
            r#"<!-- Generated by comm-node. DO NOT EDIT — this file is overwritten on every `comm-node init`. -->

# {domain_name} Domain Agent

**Domain:** {domain_name}
**Description:** {description}

## Hard Rules

These rules are non-negotiable. Follow them exactly.

1. **Check inbox before starting any new task.** Not during a task — between tasks.
2. Write all inter-agent messages to `.orchestrator/outbox/`. Never write to another domain's directories.
3. Signal task completion by writing `completion-bd-XXX.md` to outbox. Do not call `bd close` directly.
4. Update `status.json` when starting/finishing work or becoming blocked.
5. Only acquire file locks through the comm-node's lock protocol (write lock request to outbox, wait for grant in inbox).
6. Trust the comm-node. Do not attempt to discover or communicate with other agents directly.

## Domain Scope

Files this agent is responsible for:

{scopes}
## Peer Domains

Other domains in this project (communicate via outbox only):

{peers}
## `.orchestrator/` Directory Structure

```
.orchestrator/
  artifacts/      # Cross-domain work products (read)
  inbox/          # Incoming messages from comm-node (read, delete after processing)
  outbox/         # Outgoing messages to comm-node (write)
  registry.json   # Peer discovery — all domain names and descriptions (read)
  PROTOCOL.md     # Communication rules and semantic shorthand (read)
  status.json     # Your agent status (read/write)
```

## What You Read

| File | Written By | Content |
|---|---|---|
| `.orchestrator/inbox/*.md` | comm-node | Messages from other agents |
| `.orchestrator/registry.json` | comm-node | Peer domain names and descriptions |
| `.orchestrator/PROTOCOL.md` | comm-node | Communication rules and format reference |
| `.orchestrator/artifacts/*` | comm-node | Cross-domain work products |

## What You Write

| File | Read By | Content |
|---|---|---|
| `.orchestrator/outbox/*.md` | comm-node | Messages to other agents (YAML frontmatter required) |
| `.orchestrator/outbox/completion-bd-XXX.md` | comm-node | Task completion signal |
| `.orchestrator/status.json` | comm-node | Your current status |
| `.orchestrator/artifacts/*` | comm-node | Work products for other domains |

## Message Format

All outbox messages **must** include YAML frontmatter:

```yaml
---
from: {domain_name}
to: <target-domain>
type: artifact_ready | blocked | question | completion | status
task: bd-XXX
priority: high | medium | low
artifacts: []
---

Human-readable message body. Keep concise.
```

## `status.json` Schema

```json
{{
  "domain": "{domain_name}",
  "status": "idle | working | blocked | complete",
  "current_task": null,
  "last_heartbeat": "2025-01-15T10:30:00Z",
  "artifacts_produced": [],
  "blocked_on": null
}}
```

Update `status.json` whenever you start a task, finish a task, or become blocked.

## Reference

See `.orchestrator/PROTOCOL.md` for the full semantic shorthand and communication tier definitions.
"#,
            domain_name = domain_id,
            description = domain_config.description,
            scopes = scopes,
            peers = peers,
        );

        std::fs::write(&path, content)?;
        tracing::info!(domain = %domain_id, "wrote CLAUDE.md");
    }

    Ok(())
}
